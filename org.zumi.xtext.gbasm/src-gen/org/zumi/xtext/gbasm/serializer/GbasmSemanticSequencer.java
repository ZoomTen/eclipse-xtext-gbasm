/*
 * generated by Xtext 2.26.0
 */
package org.zumi.xtext.gbasm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.zumi.xtext.gbasm.gbasm.AndCp;
import org.zumi.xtext.gbasm.gbasm.Asm;
import org.zumi.xtext.gbasm.gbasm.BankReference;
import org.zumi.xtext.gbasm.gbasm.CallOrJump;
import org.zumi.xtext.gbasm.gbasm.GbasmPackage;
import org.zumi.xtext.gbasm.gbasm.LabelOrConstant;
import org.zumi.xtext.gbasm.gbasm.LabelReference;
import org.zumi.xtext.gbasm.gbasm.Ld;
import org.zumi.xtext.gbasm.gbasm.LocalLabel;
import org.zumi.xtext.gbasm.services.GbasmGrammarAccess;

@SuppressWarnings("all")
public class GbasmSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GbasmGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GbasmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GbasmPackage.AND_CP:
				sequence_AndCp(context, (AndCp) semanticObject); 
				return; 
			case GbasmPackage.ASM:
				sequence_Asm(context, (Asm) semanticObject); 
				return; 
			case GbasmPackage.BANK_REFERENCE:
				sequence_BankReference(context, (BankReference) semanticObject); 
				return; 
			case GbasmPackage.CALL_OR_JUMP:
				sequence_CallOrJump(context, (CallOrJump) semanticObject); 
				return; 
			case GbasmPackage.LABEL_OR_CONSTANT:
				sequence_LabelOrConstant(context, (LabelOrConstant) semanticObject); 
				return; 
			case GbasmPackage.LABEL_REFERENCE:
				sequence_LabelReference(context, (LabelReference) semanticObject); 
				return; 
			case GbasmPackage.LD:
				sequence_Ld(context, (Ld) semanticObject); 
				return; 
			case GbasmPackage.LOCAL_LABEL:
				sequence_LocalLabel(context, (LocalLabel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns AndCp
	 *     Instruction returns AndCp
	 *     AndCp returns AndCp
	 *
	 * Constraint:
	 *     andCpLabelRef=[LabelOrConstant|ID]
	 * </pre>
	 */
	protected void sequence_AndCp(ISerializationContext context, AndCp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GbasmPackage.Literals.AND_CP__AND_CP_LABEL_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GbasmPackage.Literals.AND_CP__AND_CP_LABEL_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndCpAccess().getAndCpLabelRefLabelOrConstantIDTerminalRuleCall_2_1_0_1(), semanticObject.eGet(GbasmPackage.Literals.AND_CP__AND_CP_LABEL_REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Asm returns Asm
	 *
	 * Constraint:
	 *     labels+=LabelOrConstant+
	 * </pre>
	 */
	protected void sequence_Asm(ISerializationContext context, Asm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns BankReference
	 *     Instruction returns BankReference
	 *     Ld returns BankReference
	 *     BankReference returns BankReference
	 *
	 * Constraint:
	 *     bankLabel=[LabelOrConstant|ID]
	 * </pre>
	 */
	protected void sequence_BankReference(ISerializationContext context, BankReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GbasmPackage.Literals.BANK_REFERENCE__BANK_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GbasmPackage.Literals.BANK_REFERENCE__BANK_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBankReferenceAccess().getBankLabelLabelOrConstantIDTerminalRuleCall_2_0_1(), semanticObject.eGet(GbasmPackage.Literals.BANK_REFERENCE__BANK_LABEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CallOrJump
	 *     Instruction returns CallOrJump
	 *     CallOrJump returns CallOrJump
	 *
	 * Constraint:
	 *     (absLabel=[LabelOrConstant|ID] | locLabel=[LocalLabel|ID])
	 * </pre>
	 */
	protected void sequence_CallOrJump(ISerializationContext context, CallOrJump semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LabelOrConstant returns LabelOrConstant
	 *
	 * Constraint:
	 *     (name=ID statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_LabelOrConstant(ISerializationContext context, LabelOrConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LabelReference
	 *     Instruction returns LabelReference
	 *     Ld returns LabelReference
	 *     LabelReference returns LabelReference
	 *
	 * Constraint:
	 *     refLabel=[LabelOrConstant|ID]
	 * </pre>
	 */
	protected void sequence_LabelReference(ISerializationContext context, LabelReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GbasmPackage.Literals.LABEL_REFERENCE__REF_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GbasmPackage.Literals.LABEL_REFERENCE__REF_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelReferenceAccess().getRefLabelLabelOrConstantIDTerminalRuleCall_0_0_1(), semanticObject.eGet(GbasmPackage.Literals.LABEL_REFERENCE__REF_LABEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Ld
	 *     Instruction returns Ld
	 *     Ld returns Ld
	 *
	 * Constraint:
	 *     locLabel=[LocalLabel|ID]
	 * </pre>
	 */
	protected void sequence_Ld(ISerializationContext context, Ld semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GbasmPackage.Literals.LD__LOC_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GbasmPackage.Literals.LD__LOC_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLdAccess().getLocLabelLocalLabelIDTerminalRuleCall_1_4_2_1_1_0_1(), semanticObject.eGet(GbasmPackage.Literals.LD__LOC_LABEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LocalLabel
	 *     LocalLabel returns LocalLabel
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_LocalLabel(ISerializationContext context, LocalLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GbasmPackage.Literals.LOCAL_LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GbasmPackage.Literals.LOCAL_LABEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalLabelAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
